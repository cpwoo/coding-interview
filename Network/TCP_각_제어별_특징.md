## 패킷 (Packet)
인터넷에서 데이터를 보내기 위한 경로 배정(라우팅)을 효율적으로 하기 위해 데이터를 여러 개의 조각으로 나누어 전송을 하게 되는데, 이때의 조각을 패킷이라 한다. 쉽게 말해 우리가 인터넷을 이용해 주고받는 이메일, 채팅 메시지, 금융 거래 내용 등 다양한 데이터의 내용을 작은 단위로 쪼갠 데이터이다. <br>
패킷은 `헤더, 데이터, 테일러`로 이루어져 있는데, 헤더에는 수신처의 인터넷 주소와 순서 등이, 테일러에는 에러 정보가 기록되어 있다.

## TCP가 패킷을 추적하고 관리하는 구조
데이터는 패킷 단위로 쪼개져 같은 목적지로 전송된다. 따라서 패킷에 각각 `번호`를 부여하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 `재조립`한다. 이런 방식으로 패킷을 추적하며, 나누어 보내진 데이터를 목적지에서 받고 재조립할 수 있다.

## TCP 흐름제어
송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 제어하기 위한 기법으로 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
- 송신하는 곳에서 감당이 안 되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
- 만약, 송신측의 전송량 > 수신측의 수신량일 경우 전송된 패킷은 수신측의 큐를 넘어서 손실될 수 있기 때문에 송신 측의 패킷 전송량을 제어하게 된다.

1. **Stop the Wait**(정지-대기)
- 매번 전송한 패킷에 대한 `확인 응답`을 받아야 그 다음 패킷을 전송할 수 있다. 이러한 구조로 인해 비효율적이라는 단점이 있다.

2. **Sliding Window**(슬라이딩 윈도우)
- `윈도우`: 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기
- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다. 따라서 송신측에서는 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다.
- 송신측에서 0, 1, 2, 3, 4, 5, 6을 보낼 수 있는 프레임을 가지고 있고 데이터 0, 1을 전송했다고 가정하면 슬라이딩 윈도우 구조는 2, 3, 4, 5, 6처럼 변하게 된다. 이때 만약 수신측으로부터 ACK라는 프레임을 받게 된다면 송신측은 이전에 보낸 0, 1을 수신측에서 정상적으로 받았음을 알게 되고 송신측의 슬라이딩 윈도우는 ACK 프레임의 수만큼 오른쪽으로 경계가 확장된다.
- Stop and Wait의 비효율성을 개선했다.

## TCP 오류제어
오류 검출과 재전송을 포함한다.
- ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다. ARQ 기법은 흐름 제어 기법과 연관되어 있다.

1. **Stop and Wait ARQ**
- 송신 측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무에 따라 ACK 혹은 NAK(Negative Acknowledgement)를 보내는 방식이다.
- 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아가며 부여한다.
- 수신측에 데이터를 받지 못했을 경우 NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다.
- 만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송한다.

2. **Go-Back-n ARQ**
- 전송된 프레임이 손상되거나 분실된 경우 그리고 ACK 패킷의 손실로 인한 TIME_OUT이 발생한 경우, 확인된 마지막 프레임 이후로 모든 프레임을 재전송한다.
- 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별해야 한다.
- ACK: 다음 프레임을 전송
- NAK: 손상된 프레임 자체 번호를 반환

**재전송 되는 경우**

(1) NAK 프레임을 받았을 경우 <br>
만약 수신측으로 0 ~ 5까지의 데이터를 보냈다고 가정했을 때, 수신측에서 데이터를 받았음을 확인하는 데이터 오류 프레임 2를 발견하고 NAK2를 전송측에 보낸다고 해보자. <br>
NAK2를 받은 전송측은 데이터 프레임 2가 잘못되었다는 것을 알고 데이터를 재전송한다. GBn ARQ의 특징은 데이터를 재전송하는 부분이다. NAK(n)를 받아 데이터를 재전송한다. 

(2) 전송 데이터 프레임의 분실 <br>
GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 프레임 재전송과 수신측의 폐기다. 수신측에서 데이터 1을 받고 다음 데이터로 3을 받게 된다면 데이터 2를 받지 못했으므로 수신측에서는 데이터 3을 폐기하고 데이터 2를 받지 못했다는 NAK2를 전송측에 보낸다. NAK를 받은 전송측은 (1)의 경우와 마찬가지로 NAK(n) 데이터로부터 모든 데이터를 재전송하며 수신측은 기존에 받았던 데이터 중 NAK(n)으로 보냈던 대상 데이터 이후의 모든 데이터를 폐기하고 재전송 받는다.

(3) 지정된 타임 아웃 내의 ACK 프레임 분실 <br>
전송측은 분실된 ACK를 다루기 위해 타이머를 가지고 있다. 또한 전송측에서는 이 타이머의 티임 아웃 동안 수신측으로부터 ACK 데이터를 받지 못했을 경우, 마지막 ACK된 데이터부터 재전송한다.

정리하자면
- 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 데이터를 재전송한다.
- 수신측은 원하는 프레임이 아닐 경우, 데이터를 모두 폐기 처분한다.
- 타임아웃(ACK 분실)의 경우, 마지막 ACK된 데이터부터 재전송한다.

3. **SR(Selective-Reject) ARQ**
- GBn ARQ의 확인된 마지막 프레임 이후의 모든 프레임을 재전송하는 단점을 보완하는 기법이다.
- SR ARQ는 손상되거나 손실된 프레임만 재전송한다.
- 그렇기 때문에 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 한다.
- 수신 측에 버퍼를 두어 받은 데이터의 정렬이 필요하다.

| GBn(Go-Back-n) ARQ | SR(Selective-Reject) ARQ |
| --- | --- |
| 손상/분실된 프레임 이후의 프레임을 모두 재전송 | 손상/분실된 프레임만을 재전송
| 구조가 비교적 간단하고 구현이 단순 | 구조가 복잡(프레임 재배열 등의 추가 로직 필요) |
| 데이터 폐기 방식을 사용하여 추가적 버퍼가 필요 없음 | 폐기 방식을 사용하지 않으므로 순차적이지 않은 프레임을 재배열하기 위한 버퍼가 필요 |
| 비용이 비교적 저렴 | 비용 및 유지관리 비용이 증가 |

## TCP 혼잡제어
- 송신측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법
- 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실 발생
- 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터 전송 속도를 제어하는 것이 혼잡 제어의 방식이다.

1. **AIMD(Additive Increase Multicative Decrease)**
- 합 증가/곱 감소 알고리즘이라고 한다.
- 처음에 패킷 하나를 보내는 것으로 시작하여 전송한 패킷이 문제 없이 도착한다면 Window Size를 1씩 증가시키며 전송하는 방법이다. 만약, 패킷 전송을 실패하거나 TIME_OUT이 발생하면 Window Size를 절반으로 감소시킨다.
- 이 방식은 공평하다. 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다.
- 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

2. **Slow Start**
- AIMD가 네트워크 수용량 주변에서는 효율적으로 동작하지만, 처음에 전송 속도를 올리는데 시간이 너무 길다는 단점이 있다.
- Slow Start는 AIMD와 마찬가지로 패킷을 하나씩 보내는 것부터 시작한다. 이 방식은 패킷이 문제 없이 동작하며 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기를 지나면 Window Size는 2배가 된다.
- 따라서 그래프의 모양은 지수 함수 꼴이 된다.
- 혼잡 현상이 발생하면 Window Size를 1로 떨어뜨린다.
- 처음에는 네트워크의 수용량을 예측할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.
- 미리 정해진 임계값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
- Slow Start라는 이름을 사용하지만, 매 전송마다 2배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수함수적으로 증가한다.
- 전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다.

<혼잡 회피(Congestion Avoidance)>
- 윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높다.
- 따라서 이를 회피하기 위해 `윈도우 크기를 선형적으로 1씩 증가시키는 방법`이다.
- 수신측으로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우
  - 타임 아웃의 발생: 네트워크 혼잡이 발생했다고 인식
  - 혼잡 상태로 인식된 경우
    - 윈도우의 크기 세그먼트 수를 1로 감소시킨다.
    - 동시에 임계값을 패킷 손실이 발생했을 때의 윈도우 크기의 절반으로 줄인다.

<빠른 회복(Fast Recovery)>
- 혼잡한 상태가 되면 Window Size를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법이다.
- 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서는 순수한 AMID 방식으로 동작하게 된다.

<빠른 재전송(Fast Retransit)>
- 수신 측에서 패킷을 받을 때 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 따라서 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하게 되면 문제가 되는 순번의 패킷을 재전송할 수 있다.
- 빠른 재전송은 중복된 순번의 패킷을 3개(3 ACK) 받으면 재전송한다. 그리고 이러한 현상이 일어나는 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 절반으로 줄인다.

참고: https://rok93.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4
